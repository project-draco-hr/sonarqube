{
  if (numberOfLoops++ > maximumNumberOfLoops) {
    return;
  }
  if (pendingWeight >= minimumFeedbackEdgesWeight) {
    return;
  }
  if (level == cyclesNumber) {
    minimumFeedbackEdgesWeight=pendingWeight;
    feedbackEdges=new LinkedHashSet<FeedbackEdge>(pendingFeedbackEdges);
    return;
  }
  FeedbackCycle feedbackCycle=feedbackCycles.get(level);
  if (doesFeedbackEdgesContainAnEdgeOfTheCycle(pendingFeedbackEdges,feedbackCycle)) {
    searchFeedbackEdges(level + 1,pendingWeight,pendingFeedbackEdges);
  }
 else {
    boolean hasAnEdgeWithOccurrenceOfOneBeenUsed=false;
    for (    FeedbackEdge feedbackEdge : feedbackCycle) {
      if (feedbackEdge.getOccurences() == 1) {
        if (hasAnEdgeWithOccurrenceOfOneBeenUsed) {
          continue;
        }
 else {
          hasAnEdgeWithOccurrenceOfOneBeenUsed=true;
        }
      }
      int edgeWeight=addNewEdge(feedbackEdge,pendingFeedbackEdges);
      pendingWeight+=edgeWeight;
      searchFeedbackEdges(level + 1,pendingWeight,pendingFeedbackEdges);
      pendingWeight-=edgeWeight;
      pendingFeedbackEdges.remove(feedbackEdge);
    }
  }
}
