{
  ExecutorService executorService=null;
  Process process=null;
  StreamGobbler outputGobbler=null;
  StreamGobbler errorGobbler=null;
  try {
    ProcessBuilder builder=new ProcessBuilder(command.toStrings(false));
    if (command.getDirectory() != null) {
      builder.directory(command.getDirectory());
    }
    builder.environment().putAll(command.getEnvironmentVariables());
    process=builder.start();
    outputGobbler=new StreamGobbler(process.getInputStream(),stdOut);
    errorGobbler=new StreamGobbler(process.getErrorStream(),stdErr);
    outputGobbler.start();
    errorGobbler.start();
    final Process finalProcess=process;
    executorService=Executors.newSingleThreadExecutor();
    Future<Integer> ft=executorService.submit(new Callable<Integer>(){
      @Override public Integer call() throws Exception {
        return finalProcess.waitFor();
      }
    }
);
    int exitCode;
    if (timeoutMilliseconds < 0) {
      exitCode=ft.get();
    }
 else {
      exitCode=ft.get(timeoutMilliseconds,TimeUnit.MILLISECONDS);
    }
    waitUntilFinish(outputGobbler);
    waitUntilFinish(errorGobbler);
    verifyGobbler(command,outputGobbler,"stdOut");
    verifyGobbler(command,errorGobbler,"stdErr");
    return exitCode;
  }
 catch (  java.util.concurrent.TimeoutException te) {
    process.destroy();
    throw new TimeoutException(command,"Timeout exceeded: " + timeoutMilliseconds + " ms",te);
  }
catch (  CommandException e) {
    throw e;
  }
catch (  Exception e) {
    throw new CommandException(command,e);
  }
 finally {
    waitUntilFinish(outputGobbler);
    waitUntilFinish(errorGobbler);
    closeStreams(process);
    if (executorService != null) {
      executorService.shutdown();
    }
  }
}
