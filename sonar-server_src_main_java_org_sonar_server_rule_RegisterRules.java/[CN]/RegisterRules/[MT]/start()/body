{
  TimeProfiler profiler=new TimeProfiler().start("Register rules");
  DbSession session=dbClient.openSession(false);
  try {
    Map<RuleKey,RuleDto> allRules=loadRules(session);
    RulesDefinition.Context context=defLoader.load();
    for (    RulesDefinition.ExtendedRepository repoDef : getRepositories(context)) {
      for (      RulesDefinition.Rule ruleDef : repoDef.rules()) {
        RuleKey ruleKey=RuleKey.of(ruleDef.repository().key(),ruleDef.key());
        RuleDto rule=allRules.containsKey(ruleKey) ? allRules.remove(ruleKey) : createRuleDto(ruleDef,session);
        boolean executeUpdate=false;
        if (mergeRule(ruleDef,rule)) {
          executeUpdate=true;
        }
        if (rule.getSubCharacteristicId() != null) {
          CharacteristicDto characteristicDto=characteristicDao.selectById(rule.getSubCharacteristicId(),session);
          if (characteristicDto != null && mergeDebtDefinitions(ruleDef,rule,characteristicDto)) {
            executeUpdate=true;
          }
        }
        if (mergeTags(ruleDef,rule)) {
          executeUpdate=true;
        }
        if (executeUpdate) {
          dbClient.ruleDao().update(session,rule);
        }
 else {
          session.enqueue(new KeyIndexAction<RuleKey>(IndexDefinition.RULE.getIndexType(),IndexAction.Method.UPSERT,rule.getKey()));
        }
        mergeParams(ruleDef,rule,session);
      }
      session.commit();
    }
    List<RuleDto> activeRules=processRemainingDbRules(allRules.values(),session);
    removeActiveRulesOnStillExistingRepositories(activeRules,context);
    session.commit();
  }
  finally {
    session.close();
    profiler.stop();
  }
}
