{
  Collection<DefaultIssue> issues=Lists.newArrayList();
  for (  Issue issue : issueCache.byComponent(component.resource().getEffectiveKey())) {
    issues.add((DefaultIssue)issue);
  }
  issueCache.clear(component.resource().getEffectiveKey());
  if (analysisMode.isIncremental() && !component.isFile()) {
    return;
  }
  Collection<ServerIssue> previousIssues=new ArrayList<>();
  for (  org.sonar.batch.protocol.input.BatchInput.ServerIssue previousIssue : serverIssueRepository.byComponent(component)) {
    previousIssues.add(new ServerIssueFromWs(previousIssue));
  }
  SourceHashHolder sourceHashHolder=null;
  if (component.isFile()) {
    DefaultInputFile file=(DefaultInputFile)inputPathCache.getInputPath(component);
    if (file == null) {
      throw new IllegalStateException("Resource " + component.resource() + " was not found in InputPath cache");
    }
    sourceHashHolder=new SourceHashHolder((DefaultInputFile)file,lastLineHashes);
  }
  IssueTrackingResult trackingResult=tracking.track(sourceHashHolder,previousIssues,issues);
  addUnmatched(trackingResult.unmatched(),sourceHashHolder,issues);
  mergeMatched(trackingResult);
  if (ResourceUtils.isRootProject(component.resource())) {
    addIssuesOnDeletedComponents(issues);
  }
  for (  DefaultIssue issue : issues) {
    workflow.doAutomaticTransition(issue,changeContext);
    issueCache.put(issue);
  }
}
