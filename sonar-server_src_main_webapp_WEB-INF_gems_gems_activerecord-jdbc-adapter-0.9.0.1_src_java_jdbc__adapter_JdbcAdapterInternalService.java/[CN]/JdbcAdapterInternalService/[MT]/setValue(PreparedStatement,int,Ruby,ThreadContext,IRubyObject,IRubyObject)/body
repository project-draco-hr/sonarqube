{
  final int tp=getTypeValueFor(runtime,type);
  if (value.isNil()) {
    ps.setNull(index,tp);
    return;
  }
switch (tp) {
case Types.VARCHAR:
case Types.CLOB:
    ps.setString(index,RubyString.objAsString(context,value).toString());
  break;
case Types.INTEGER:
ps.setLong(index,RubyNumeric.fix2long(value));
break;
case Types.FLOAT:
ps.setDouble(index,((RubyNumeric)value).getDoubleValue());
break;
case Types.TIMESTAMP:
case Types.TIME:
case Types.DATE:
if (!(value instanceof RubyTime)) {
try {
Date dd=FORMAT.parse(RubyString.objAsString(context,value).toString());
ps.setTimestamp(index,new java.sql.Timestamp(dd.getTime()),Calendar.getInstance());
}
 catch (Exception e) {
ps.setString(index,RubyString.objAsString(context,value).toString());
}
}
 else {
RubyTime rubyTime=(RubyTime)value;
java.util.Date date=rubyTime.getJavaDate();
long millis=date.getTime();
long micros=rubyTime.microseconds() - millis / 1000;
java.sql.Timestamp ts=new java.sql.Timestamp(millis);
java.util.Calendar cal=Calendar.getInstance();
cal.setTime(date);
ts.setNanos((int)(micros * 1000));
ps.setTimestamp(index,ts,cal);
}
break;
case Types.BOOLEAN:
ps.setBoolean(index,value.isTrue());
break;
default :
throw new RuntimeException("type " + type + " not supported in _bind yet");
}
}
