{
  try {
    int n;
switch (type) {
case Types.BINARY:
case Types.BLOB:
case Types.LONGVARBINARY:
case Types.VARBINARY:
      InputStream is=rs.getBinaryStream(row);
    if (is == null || rs.wasNull()) {
      return runtime.getNil();
    }
  ByteList str=new ByteList(2048);
byte[] buf=new byte[2048];
while ((n=is.read(buf)) != -1) {
str.append(buf,0,n);
}
is.close();
return runtime.newString(str);
case Types.LONGVARCHAR:
case Types.CLOB:
Reader rss=rs.getCharacterStream(row);
if (rss == null || rs.wasNull()) {
return runtime.getNil();
}
StringBuffer str2=new StringBuffer(2048);
char[] cuf=new char[2048];
while ((n=rss.read(cuf)) != -1) {
str2.append(cuf,0,n);
}
rss.close();
return RubyString.newUnicodeString(runtime,str2.toString());
case Types.TIMESTAMP:
Timestamp time=rs.getTimestamp(row);
if (time == null || rs.wasNull()) {
return runtime.getNil();
}
String sttr=time.toString();
if (sttr.endsWith(" 00:00:00.0")) {
sttr=sttr.substring(0,sttr.length() - (" 00:00:00.0".length()));
}
return RubyString.newUnicodeString(runtime,sttr);
default :
String vs=rs.getString(row);
if (vs == null || rs.wasNull()) {
return runtime.getNil();
}
return RubyString.newUnicodeString(runtime,vs);
}
}
 catch (IOException ioe) {
throw (SQLException)new SQLException(ioe.getMessage()).initCause(ioe);
}
}
