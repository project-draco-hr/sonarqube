{
  String projectKey=reactor.getRoot().getKeyWithBranch();
  String url=BATCH_PROJECT_URL + "?key=" + projectKey;
  if (taskProperties.properties().containsKey(ModuleQProfiles.SONAR_PROFILE_PROP)) {
    try {
      url+="&profile=" + URLEncoder.encode(taskProperties.properties().get(ModuleQProfiles.SONAR_PROFILE_PROP),"UTF-8");
    }
 catch (    UnsupportedEncodingException e) {
      throw new IllegalStateException("Unable to encode URL",e);
    }
  }
  url+="&preview=" + analysisMode.isPreview();
  ProjectReferentials ref=ProjectReferentials.fromJson(serverClient.request(url));
  Integer lastCommitsId=metricFinder.findByKey(CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE.key()).getId();
  Integer revisionsId=metricFinder.findByKey(CoreMetrics.SCM_REVISIONS_BY_LINE.key()).getId();
  Integer authorsId=metricFinder.findByKey(CoreMetrics.SCM_AUTHORS_BY_LINE.key()).getId();
  for (  Map.Entry<String,String> hashByPaths : fileHashLoader.hashByRelativePath().entrySet()) {
    String path=hashByPaths.getKey();
    String hash=hashByPaths.getValue();
    String lastCommits=null;
    String revisions=null;
    String authors=null;
    List<MeasureModel> measures=defaultTimeMachine.query(projectKey + ":" + path,lastCommitsId,revisionsId,authorsId);
    for (    MeasureModel m : measures) {
      if (m.getMetricId() == lastCommitsId) {
        lastCommits=m.getData(CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE);
      }
 else       if (m.getMetricId() == revisionsId) {
        revisions=m.getData(CoreMetrics.SCM_REVISIONS_BY_LINE);
      }
      if (m.getMetricId() == authorsId) {
        authors=m.getData(CoreMetrics.SCM_AUTHORS_BY_LINE);
      }
    }
    ref.fileDataPerPath().put(path,new FileData(hash,lastCommits,revisions,authors));
  }
  return ref;
}
