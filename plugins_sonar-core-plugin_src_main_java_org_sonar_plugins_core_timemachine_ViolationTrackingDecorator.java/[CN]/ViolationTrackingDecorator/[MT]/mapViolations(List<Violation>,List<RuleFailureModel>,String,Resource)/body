{
  boolean hasLastScan=false;
  Multimap<Integer,RuleFailureModel> lastViolationsByRule=LinkedHashMultimap.create();
  if (lastViolations != null) {
    hasLastScan=true;
    unmappedLastViolations.addAll(lastViolations);
    for (    RuleFailureModel lastViolation : lastViolations) {
      lastViolationsByRule.put(lastViolation.getRuleId(),lastViolation);
    }
    for (    Violation newViolation : newViolations) {
      mapViolation(newViolation,findLastViolationWithSamePermanentId(newViolation,lastViolationsByRule.get(newViolation.getRule().getId())),lastViolationsByRule,referenceViolationsMap);
    }
    for (    Violation newViolation : newViolations) {
      if (isNotAlreadyMapped(newViolation)) {
        mapViolation(newViolation,findLastViolationWithSameLineAndChecksum(newViolation,lastViolationsByRule.get(newViolation.getRule().getId())),lastViolationsByRule,referenceViolationsMap);
      }
    }
  }
  if (referenceViolationsMap.size() != newViolations.size()) {
    if (source != null && resource != null && hasLastScan) {
      String referenceSource=lastSnapshots.getSource(resource);
      if (referenceSource != null) {
        HashedSequence<StringText> hashedReference=HashedSequence.wrap(new StringText(referenceSource),StringTextComparator.IGNORE_WHITESPACE);
        HashedSequence<StringText> hashedSource=HashedSequence.wrap(new StringText(source),StringTextComparator.IGNORE_WHITESPACE);
        HashedSequenceComparator<StringText> hashedComparator=new HashedSequenceComparator<StringText>(StringTextComparator.IGNORE_WHITESPACE);
        ViolationTrackingBlocksRecognizer rec=new ViolationTrackingBlocksRecognizer(hashedReference,hashedSource,hashedComparator);
        Multimap<Integer,Violation> newViolationsByLines=newViolationsByLines(newViolations,rec);
        Multimap<Integer,RuleFailureModel> lastViolationsByLines=lastViolationsByLines(unmappedLastViolations,rec);
        RollingHashSequence<HashedSequence<StringText>> a=RollingHashSequence.wrap(hashedReference,hashedComparator,5);
        RollingHashSequence<HashedSequence<StringText>> b=RollingHashSequence.wrap(hashedSource,hashedComparator,5);
        RollingHashSequenceComparator<HashedSequence<StringText>> cmp=new RollingHashSequenceComparator<HashedSequence<StringText>>(hashedComparator);
        Map<Integer,HashOccurrence> map=Maps.newHashMap();
        for (        Integer line : lastViolationsByLines.keySet()) {
          int hash=cmp.hash(a,line - 1);
          HashOccurrence hashOccurrence=map.get(hash);
          if (hashOccurrence == null) {
            hashOccurrence=new HashOccurrence();
            hashOccurrence.lineA=line;
            hashOccurrence.countA=1;
            map.put(hash,hashOccurrence);
          }
 else {
            hashOccurrence.countA++;
          }
        }
        for (        Integer line : newViolationsByLines.keySet()) {
          int hash=cmp.hash(b,line - 1);
          HashOccurrence hashOccurrence=map.get(hash);
          if (hashOccurrence != null) {
            hashOccurrence.lineB=line;
            hashOccurrence.countB++;
          }
        }
        for (        HashOccurrence hashOccurrence : map.values()) {
          if (hashOccurrence.countA == 1 && hashOccurrence.countB == 1) {
            LOG.debug("*** Guaranteed that lineA has been moved to lineB, so we can map all issues on lineA to all issues on lineB");
            map(newViolationsByLines.get(hashOccurrence.lineB),lastViolationsByLines.get(hashOccurrence.lineA),lastViolationsByRule);
            lastViolationsByLines.removeAll(hashOccurrence.lineA);
            newViolationsByLines.removeAll(hashOccurrence.lineB);
          }
        }
        if (lastViolationsByLines.keySet().size() * newViolationsByLines.keySet().size() < 250000) {
          List<LinePair> possibleLinePairs=Lists.newArrayList();
          for (          Integer oldLine : lastViolationsByLines.keySet()) {
            for (            Integer newLine : newViolationsByLines.keySet()) {
              int weight=rec.computeLengthOfMaximalBlock(oldLine - 1,newLine - 1);
              possibleLinePairs.add(new LinePair(oldLine,newLine,weight));
            }
          }
          Collections.sort(possibleLinePairs,LINE_PAIR_COMPARATOR);
          for (          LinePair linePair : possibleLinePairs) {
            LOG.debug("*** High probability that lineA has been moved to lineB, so we can map all Issues on lineA to all Issues on lineB");
            map(newViolationsByLines.get(linePair.lineB),lastViolationsByLines.get(linePair.lineA),lastViolationsByRule);
          }
        }
      }
    }
    for (    Violation newViolation : newViolations) {
      if (isNotAlreadyMapped(newViolation)) {
        LOG.debug("*** Try then to match issues on same rule with same message and with same checksum");
        mapViolation(newViolation,findLastViolationWithSameChecksumAndMessage(newViolation,lastViolationsByRule.get(newViolation.getRule().getId())),lastViolationsByRule,referenceViolationsMap);
      }
    }
    for (    Violation newViolation : newViolations) {
      if (isNotAlreadyMapped(newViolation)) {
        LOG.debug("*** Try then to match issues on same rule with same line and with same message");
        mapViolation(newViolation,findLastViolationWithSameLineAndMessage(newViolation,lastViolationsByRule.get(newViolation.getRule().getId())),lastViolationsByRule,referenceViolationsMap);
      }
    }
    for (    Violation newViolation : newViolations) {
      if (isNotAlreadyMapped(newViolation)) {
        LOG.debug("*** Last check: match issue if same rule and same checksum but different line and different message");
        mapViolation(newViolation,findLastViolationWithSameChecksum(newViolation,lastViolationsByRule.get(newViolation.getRule().getId())),lastViolationsByRule,referenceViolationsMap);
      }
    }
  }
  unmappedLastViolations.clear();
  return referenceViolationsMap;
}
