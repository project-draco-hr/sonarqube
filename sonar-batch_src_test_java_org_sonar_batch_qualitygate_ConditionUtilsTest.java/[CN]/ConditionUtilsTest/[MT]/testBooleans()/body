{
  metric.setType(Metric.ValueType.BOOL);
  measure.setValue(0d);
  when(condition.operator()).thenReturn(QualityGateConditionDto.OPERATOR_EQUALS);
  when(condition.metric()).thenReturn(metric);
  when(condition.errorThreshold()).thenReturn("1");
  assertThat(ConditionUtils.getLevel(condition,measure)).isEqualTo(Metric.Level.OK);
  when(condition.errorThreshold()).thenReturn("0");
  assertThat(ConditionUtils.getLevel(condition,measure)).isEqualTo(Metric.Level.ERROR);
  when(condition.operator()).thenReturn(QualityGateConditionDto.OPERATOR_NOT_EQUALS);
  when(condition.errorThreshold()).thenReturn("1");
  assertThat(ConditionUtils.getLevel(condition,measure)).isEqualTo(Metric.Level.ERROR);
  when(condition.errorThreshold()).thenReturn("0");
  assertThat(ConditionUtils.getLevel(condition,measure)).isEqualTo(Metric.Level.OK);
  when(condition.errorThreshold()).thenReturn("polop");
  try {
    ConditionUtils.getLevel(condition,measure);
    fail();
  }
 catch (  Exception expected) {
    assertThat(expected).isInstanceOf(IllegalArgumentException.class).hasMessage("Unable to parse value 'polop' to compare against name");
  }
}
