{
  LOG.debug("Detection of duplications for {}",resource);
  BatchComponent component=batchComponentCache.get(resource);
  if (component == null) {
    LOG.error("Resource not found in component cache: {}. Skipping CPD computation for it",resource);
    return;
  }
  InputFile inputFile=(InputFile)component.inputComponent();
  progressReport.message(String.format("%d/%d - current file: %s",count,total,inputFile));
  List<CloneGroup> duplications;
  Future<List<CloneGroup>> futureResult=null;
  try {
    futureResult=executorService.submit(new Callable<List<CloneGroup>>(){
      @Override public List<CloneGroup> call() throws Exception {
        return SuffixTreeCloneDetectionAlgorithm.detect(index,fileBlocks);
      }
    }
);
    duplications=futureResult.get(TIMEOUT,TimeUnit.SECONDS);
  }
 catch (  TimeoutException e) {
    LOG.warn("Timeout during detection of duplications for " + inputFile,e);
    if (futureResult != null) {
      futureResult.cancel(true);
    }
    return;
  }
catch (  Exception e) {
    throw new IllegalStateException("Fail during detection of duplication for " + inputFile,e);
  }
  List<CloneGroup> filtered;
  if (!"java".equalsIgnoreCase(inputFile.language())) {
    Predicate<CloneGroup> minimumTokensPredicate=DuplicationPredicates.numberOfUnitsNotLessThan(getMinimumTokens(inputFile.language()));
    filtered=from(duplications).filter(minimumTokensPredicate).toList();
  }
 else {
    filtered=duplications;
  }
  saveDuplications(component,filtered);
}
